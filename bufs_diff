16,18c16,17
< 
< class BufsFileSystem
< 
---
> class BufsInfoDoc
>  
23c22,24
<   include BufsFileEnvMethods 
---
>   include BufsInfoDocEnvMethods 
>   AttachmentBaseID = "_attachments"
>   LinkBaseID = "_links"
27a29,38
>                                #:db_user_id,
>                                #:db,
>                                #:collection_namespace,
>                                #:design_doc,
>                                #:query_all,
>                                #:db_metadata_keys,
>                                #:namespace,
>                                #:files_mgr,
>                                #:views_mgr,
>                                #:model_save_params,#Below here are the new accessors
29a41,45
>   ##Instance Accessors
>   attr_accessor :user_data, :model_metadata, :saved_to_model
> 
>   ###Class Methods
>   ##Class Environment
32,38c48
<     @metadata_keys = DataStoreModels::FileStore::MetadataKeys
<   end
< 
<   #put attachClass here
< 
<   def self.all_native_records
<     @class_env.query_all
---
>     @metadata_keys = DataStoreModels::CouchRest::MetadataKeys
41,61d50
<   #call view goes here
< 
<   #get(id) goes here
< 
<   def self.destroy_all
<     all_records = self.all_native_records
<     #raise "BFS about to destroy: #{all_records.inspect}"
<     @class_env.destroy_bulk(all_records)
<     #all_records.each do |record|
<     #  @class_env.delete(record)
<     #end
<   end
<  #bind to directory model
<   #must be set before it can be used
<   #child classes should set this in their
<   #class definitions
<  #---
<   def self.use_directory(bfs_dir)
<     @bfs_dir = bfs_dir
<     FileUtils.mkdir_p(File.expand_path(@bfs_dir))
<   end
63,64c52,56
<   def self.namespace
<     @bfs_dir
---
>   ##Associated Classes (e.g., for attachments)
>   #This should be defined in the dynamic class definition
>   #The default value here is for teting basic functionality
>   def self.user_attachClass
>     @class_env.user_attachClass #BufsInfoAttachment #this should be overwritten
67,108c59,62
<   def self.data_file_name
<     ".node_data.json"
<   end
< 
<   def self.link_file_name
<     ".link_data.json"
<   end
< 
<   #TODO: Remove the hard coding of data as filenames and use 
<   #config file
<   def parent_categories_file_basename
<     "parent_categories.txt"
<   end
< 
<  #---
< 
<   #overwrite these in the dynamic class definition
<   #---
<   #@base_dir = nil
<   #@namespace = nil
<   #create the operating directory for the class
<   #@model_dir = "#{@base_dir}/#{@namespace}"
<   #File.mkdir_p(File.expand_path(@model_dir))
<   #---
<   #@name_space = nil
<   #@win_dir = 'windows_format'
<   #@linux_dir = 'mac_linux_format'
<   #@parent_categories_file_basename = 'parent_categories.txt'
<   #@description_file_basename = 'description.txt'
< 
< 
<   #TODO: Determine if there's a way for file_metadata and filename to be added dynamically
<   attr_accessor :file_metadata, :filename, 
<                 :my_dir, :attached_files, :user_data, :model_metadata
< 
<   def self.model_dir
<     "#{@base_dir}/#{self.class.namespace}"
<   end
<   #def self.set_name_space(model_dir)
<   #   FileUtils.mkdir_p(File.expand_path(model_dir))
<   #   BufsFileSystem.name_space = model_dir
<   #   self.normalize
---
>   #This should be defined in the dynamic class definition
>   #The default value here is for teting basic functionality
>   #def self.user_linkClass
>   #  BufsInfoLink  #this should be overwritten
111,131c65,74
<   #This method will go through the entire model directory and make sure
<   #all file names have been normalized (remove strange characters)
<   #DANGER: this will fail if there are files in the directory that reduce to the same normalized name
<   def self.normalize
<     unless File.exists?(BufsFileSystem.name_space)
<       raise "Cannot normalize. The File System Directory to work from does not exist: #{BufsFileSystem.name_space}"
<     end
<     my_dir = self.class.name_space + '/'
<     all_entries = Dir.working_entries(my_dir)
<     all_entries.each do |cat_entry|
<       wkg_dir = my_dir + cat_entry + '/'
<       files = Dir.file_data_entries(wkg_dir)
<       files.each do |f|
<         esc_f = ::BufsEscape.escape(f)
<         unless f == esc_f
<           full_f = wkg_dir + f
<           full_esc_f = wkg_dir + esc_f
<           FileUtils.mv(full_f, full_esc_f)
<         end
<       end
<     end
---
>   ##Collection Methods
>   #This returns all db records, but does not create
>   #an instance of this class for each record.  Each record is provided
>   #in its native form.
>   def self.all_native_records
>     #query db
>     #raw_res = self.design_doc.view self.query_all
>     raw_res = @class_env.query_all
>     #raw_data = raw_res["rows"]
>     #records = raw_data.map {|d| d['value']}#puts "raw_datum: #{d.inspect}"}
134c77,78
<   #TODO: Harmonize this across models
---
>   #convert collection of CouchRest::Document into a
>   #collection of this class
136,187c80,81
<     entries = self.all_native_records
<     nodes = []
<     entries.each do |entry|
<       data_path = File.join(self.class_env.namespace, entry, self.class_env.data_file_name)
<       data_json = File.open(data_path, 'r'){|f| f.read}
<       data = JSON.parse(data_json)
<       nodes << self.new(data)
<     end
<     nodes
< =begin
<     top_dir = self.class_env.namespace
<     unless File.exists?(top_dir)
<       raise "Can't get all. The File System Directory to work from does not exist: #{top_dir}"
<     end
<     all_nodes = []
<     #my_dir = self.namespace + '/'
<     all_entries = Dir.working_entries(top_dir)
<     all_entries.each do |cat_entry|
<       wkg_dir = File.join(top_dir, cat_entry) #my_dir + cat_entry + '/'
<       cat_name = cat_entry
<       #raise "set data file name"
<       data_fname = self.class_env.data_file_name
<       bfs = nil
<       data_path = File.join(wkg_dir, data_fname)
<       if File.exists?(data_path)
<        bfs_data = JSON.parse(File.open(data_path) {|f| f.read})
<        bfs_data = HashKeys.str_to_sym(bfs_data)
<         bfs = self.new(bfs_data) if bfs_data[:my_category]  #FIXME What to do when required cat doesn't exist?
<         files = Dir.file_data_entries(wkg_dir)
<         files.each do |f|
<           full_filename = wkg_dir + '/' + f
<           bfs.add_data_file(full_filename)
<         end
< 
<       end
<       #file_mod_time = File.mtime(wkg_dir + cat_entry) if File.exists?(wkg_dir + cat_entry)
<       #f_metadata = {'file_modified' => file_mod_time.to_s} if file_mod_time
<       #bfs =  BufsFileSystem.new(:parent_categories => parent_cats,
<       #                                     :my_category => cat_name,
<       #                                     :description => desc)#,
<       #                                     #:file_metadata => f_metadata)
<       #bfs = BufsFileSystem.new(bfs_data)
<       #files = Dir.file_data_entries(wkg_dir)
<       #files.each do |f|
<       #  full_filename = wkg_dir + '/' + f
<       #  bfs.add_data_file(full_filename)
<       #end
<       all_nodes << bfs if bfs
< 
<     end
<     all_nodes 
< =end
---
>     nodes = self.all_native_records
>     nodes.map! {|n| self.new(n)}
190c84,87
< 
---
>   ## CouchDB View Creation
>   #View as it is referred to here is a query to the underlying model
>   #and structures the way the result is returned from the model.
>   #The view her
192,195c89,154
<     view_method_name = "by_#{param}".to_sym
<     records = if @class_env.views_mgr.respond_to? view_method_name
<       #TODO: info and file differ in their use of namepsapce here
<       @class_env.views_mgr.__send__(view_method_name, @class_env.namespace, match_keys)
---
>      view_method_name = "by_#{param}".to_sym #using CouchDB style for now
>      #If the views_mgr object has a view for this parameter then use it
>      records = if @class_env.views_mgr.respond_to? view_method_name
>        #TODO Make distinction clearer between namespace and collection_namespace
>        @class_env.views_mgr.__send__(view_method_name, @class_env.collection_namespace, match_keys)
>      else
>        #TODO: Think of a more elegant way to handle an unknown view
>        raise "Unknown design view #{view_method_name} called for: #{param}"
>      end
>      nodes = records.map{|r| self.new(r)}
>   end
> 
>   def self.get(id)
>     #maybe put in some validations to ensure its from the proper collection namespace?
>     rtn = begin
>       data = @class_env.db.get(id)
>       self.new(data)
>     rescue RestClient::ResourceNotFound => e
>       nil
>     end
>     rtn
>   end
> 
>   #This destroys all nodes in the model
>   #this is more efficient than calling
>   #destroy on instances of this class
>   #as it avoids instantiating only to destroy it
>   def self.destroy_all
>     all_records = self.all_native_records
>     @class_env.destroy_bulk(all_records)
>     #all_records.each do |record|
>     #  #self.db.delete_doc(record)
>     #  @class_env.db.delete_doc(record)
>     #end
>     ##The below  might work if 'couchrest-type' is used
>     #all_docs.each {|doc| doc.destroy} 
>     #nil
>   end
> 
>   #I can't figure out how to abstract the queries on collections
>   #to be either model independent or parameter independent.
>   #Each model has different ways of querying collections, and different paramter
>   #data structures need to be mapped in different ways.
> 
>   ##Class methods 
>   #Create the document in the BUFS node format from an existing node.  A BUFS node is an object that has the following properties:
>   #  my_category
>   #  parent_categories
>   #  description
>   #  attachments in the form of data files
>   #
>   def self.create_from_file_node(node_obj)
>     #TODO Update this to support the new dynamic architecture once
>     #file node is updated to the new architecture
>     init_params = {}
>     init_params['my_category'] = node_obj.my_category
>     init_params['description'] = node_obj.description if (node_obj.respond_to?(:description) && node_obj.description)
>     new_bid = self.new(init_params)
>     new_bid.add_parent_categories(node_obj.parent_categories)
>     new_bid.save
>     new_bid.add_data_file(node_obj.list_attached_files) if node_obj.list_attached_files
>     #TODO Add to spec test for links
>     if node_obj.respond_to?(:list_links) && (node_obj.list_links.nil? || node_obj.list_links.empty?)
>       #do nothing, no link data
>     elsif node_obj.respond_to?(:list_links) 
>       new_bid.add_links(node_obj.list_links)
197,198c156
<       #TODO: Think of a more elegant way to handle an unknown view
<       raise "Unknown design view #{view_method_name} called for: #{param}"
---
>       #do nothing, no link mehtod
200c158
<     nodes = records.map{|r| self.new(r)}
---
>     return new_bid.class.get(new_bid['_id'])
203,225c161,165
<   def self.by_my_category(my_cat)
<     puts "Warning:: Calling views by directly attached methods may be deprecated in the future"
<     self.call_view(:my_category, my_cat)
<   end
< =begin
<     #raise "nt: #{nodetest.my_category.inspect}" if nodetest
<     raise "No category provided for search" unless my_cat
<     #puts "Searching for #{my_cat.inspect}"
<     my_dir = self.namespace + '/'
<     my_cat_dir = my_cat
<     wkg_dir = my_dir + my_cat_dir + '/'
<     if File.exists?(wkg_dir)
<       #added 2/24 at 10:23 am due to spec failure in sync_node seems like BufsFileSystem bug fix
<       node_data  = JSON.parse(File.open(wkg_dir + self.data_file_name){|f| f.read})
<       bfs = self.new(node_data)
<       bfss = []
<       bfss << bfs 
<       return bfss   #returned as an array for compatibility with other search and node types
<     else
<       puts "Warning: #{wkg_dir.inspect} was not found"
<       return nil
<     end
< =end
---
>   #Returns the id that will be appended to the document ID to uniquely
>   #identify attachment documents associated with the main document
>   def self.attachment_base_id
>     AttachmentBaseID 
>   end
227,240c167,170
<   def self.by_parent_categories(par_cats)
<     puts "Warning:: Calling views by directly attached methods may be deprecated in the future"
<     self.call_view(:parent_categories, par_cats)
<   end
< =begin
<     par_cats = [par_cats].flatten
<     matched_nodes = []
<     all_nodes = self.all
<     par_cats.each do |par_cat|
<       all_nodes.each do |node|
<         matched_nodes << node if node.parent_categories.include?(par_cat)
<       end 
<     end
<     return matched_nodes
---
>   #Returns the id that will be appended to the document ID to uniquely
>   #identify link documents associated with the main document
>   def self.link_base_id
>     LinkBaseID 
242d171
< =end
243a173,178
>   #Normal instantiation can take two forms that differ only in the source
>   #for the initial parameters.  The constructor could be called by the user
>   #and passed only user data, or the constructor could be called by a class
>   #collection method and the initial parameters would come from a datastore.
>   #In the latter case, some of the parameters will include information about
>   #the datastore (model metadata).
245c180,182
<     @saved_to_model = nil #TODO rename to sychronized_to_model
---
>     ##temporary holding area, these need to move somewhere else
>     ##
>     @saved_to_model = nil  #TODO rename to sychronized_to_model
250,251d186
<     #raise "No parameters were passed to #{self.class} initialization" if (init_params.nil?||init_params.empty?)
<     #raise "No directory has been set for #{self}" unless self.class.namespace
253,254c188,189
<     @model_metadata = update_model_metadata(@model_metadata, node_key)
<     #@node_data_hash = {}
---
>     @model_metadata = update_model_metadata(@model_metadata,node_key)
>     
256c191
<       iv_set(attr_name.to_sym, attr_value)
---
>       iv_set(attr_name.to_sym, attr_value) 
258,264d192
<     #Hack to get around the fact that if my_category hasn't been set
<     #then there is no my_category method either
<     #iv_set(:my_category, nil)
<     #raise "NS: #{self.class.namespace.inspect} My Cat: #{self.my_category.inspect}"
<     #@my_dir = self.class.namespace + '/' + self.my_category + '/' if self.my_category
< 
<     @attached_files = []
268c196
<     model_metadata_keys = DataStoreModels::FileStore::MetadataKeys 
---
>     model_metadata_keys = DataStoreModels::CouchRest::MetadataKeys 
277d204
<     #raise user_data.inspect
281c208
<       raise ArgumentError, "Requires a value to be assigned to the key #{rk.inspect} for instantiation" unless user_data[rk]
---
>       raise ArgumentError, "Requires a value to be assigned to the key #{rk} for instantiation" unless user_data[rk]
284c211
<   
---
> 
300,302c227,229
<     model_key = DataStoreModels::FileStore::ModelKey
<     version_key = DataStoreModels::FileStore::VersionKey
<     namespace_key = DataStoreModels::FileStore::NamespaceKey
---
>     model_key = DataStoreModels::CouchRest::ModelKey
>     version_key = DataStoreModels::CouchRest::VersionKey
>     namespace_key = DataStoreModels::CouchRest::NamespaceKey
306,307c233,235
<     namespace = @bfs_dir unless namespace #self.class.class_env.collection_namespace unless namespace
<     #id = DataStoreModels::CouchRest.generate_model_key(namespace, node_key) unless id  #faster without the conditional?
---
>     #id = self.class.db_id(node_key) unless id
>     namespace = self.class.class_env.collection_namespace unless namespace
>     id = DataStoreModels::CouchRest.generate_model_key(namespace, node_key) unless id  #faster without the conditional?
309c237
<     #updated_key_metadata.delete(version_key) unless rev  #TODO Is this too model specific?
---
>     updated_key_metadata.delete(version_key) unless rev  #TODO Is this too model specific?
311,316c239,244
<     #if rev 
<     #  @saved_to_model = rev 
<     #  metadata.merge!({version_key => rev}) 
<     #else
<     #  metadata.delete(version_key)  #TODO  Is this too model specific?
<     #end
---
>     if rev 
>       @saved_to_model = rev 
>       metadata.merge!({version_key => rev}) 
>     else
>       metadata.delete(version_key)  #TODO  Is this too model specific?
>     end
320,325c248,258
<   #this method is basically to make it sort of act like a hash and struct
<   #FIXME: IMPORTANT: This breaks under some circumstances of dynamic classing
<   #When a new instance is created from the same class, these methods are
<   #recreated and use the new instances hash?  At least I think that's what's
<   #going on.  Need to isolate and test.  Work around is to use the hash to
<   #access the data
---
>   #TODO There should be a better way that combines assign user node key
>   #def get_model_key
>   #  #FIXME: Should come from model data, not hard coded
>   #  '_id'
>   #end
> 
>   #This will take a key-value pair and create an instance variable (actually it's a method)
>   # using key as the method name, and sets the return value to the value associated with that key
>   # changes to the key's value are reflected in subsequent method calls, and the value can be 
>   # updated by using method_name = some value.  Additionally, any custom operations that have been
>   # defined for that key name will be loaded in and assigned methods in the form methodname_operation
327c260
<     ops = NodeElementOperations::Ops
---
>     ops = NodeElementOperations::Ops 
329,331c262,264
<     #update the data store
<     @user_data[attr_var] = attr_value
<     #instance_variable_set("@#{attr_var}", attr_value)
---
>     @user_data[attr_var] = attr_value unless self.class.metadata_keys.include? attr_var.to_sym #self.class.db_metadata_keys.include? attr_var.to_s
>     #manually setting instance variable (rather than using instance_variable_set),
>     # so @node_data_hash can be updated
336c269
<     self.class.__send__(:define_method, "#{attr_var}=".to_sym, 
---
>     self.class.__send__(:define_method, "#{attr_var}=".to_sym,
338,342d270
<     #why not just use instance variables?
<     #because instance variables don't have a callback method
<     #that would allow me to update the data store (@node_data_hash)
<     #the data store is needed to iterate over all values stored by 
<     #the instance
344c272
<   
---
>      
346,355c274,279
<     ops.each do |op_name, op_proc|
<       method_name = "#{param.to_s}_#{op_name.to_s}".to_sym
<       wrapped_op = method_wrapper(param, op_proc)
<       self.class.__send__(:define_method, method_name, wrapped_op)
<     end
<   end 
< 
<   #TODO: If a wrapper it is applied the data will be saved to the model
<   #      This creates a bit of inconsistent behavior between data w/o operations
<   #      and data with operations.  See if it can be made consistent.
---
>        ops.each do |op_name, op_proc|
>          method_name = "#{param.to_s}_#{op_name.to_s}".to_sym
>          wrapped_op = method_wrapper(param, op_proc)
>          self.class.__send__(:define_method, method_name, wrapped_op)
>        end
>   end  
371c295
<     #lambda {|other| @user_data[param] = unbound_op.call(@user_data[param], other)}
---
>     #lambda {|other| @node_data_hash[param] = unbound_op.call(@node_data_hash[param], other)}
385,388c309,311
<   #TODO: Add to spec
<   def path_to_node_data
<     raise "The category has not been set for #{self}" unless self.my_category
<     self.class.namespace + '/' + self.my_category
---
>   def iv_unset(param)
>     self.class.__send__(:remove_method, param.to_sym)
>     @user_data.delete(param)
391,392c314,316
<   def to_hash
<     @user_data
---
>   #some object convenience methods for accessing class methods
>   def files_mgr
>     self.class.files_mgr
394a319,320
> 
>   #Save the object to the CouchDB database
400,404c326,328
<     #raise model_data.inspect
<     #TODO decide between explicit parameter passing vs keeping model stuff in model
<     res = DataStoreModels::FileStore.save(self.class.class_env.model_save_params, model_data)
<     version_key = DataStoreModels::FileStore::VersionKey
<     rev_data = {version_key => res['rev'].to_s}
---
>     res = DataStoreModels::CouchRest.save(self.class.class_env.model_save_params, model_data)
>     version_key = DataStoreModels::CouchRest::VersionKey
>     rev_data = {version_key => res['rev']}
406,430c330
<     #unless self.my_category
<     #  raise ArgumentError, "Requires my_category to be set before saving"
<     #end
<     #TODO: If parent categories are not mandatory the code raising an error can be removed
<     #if self.parent_categories.nil? || self.parent_categories.empty?
<     #  raise ArgumentError, "Requires at least one parent category to be set before saving"
<     #end
< 
<     #make model directory
<       #debug for permissions problems
<       #FileUtils.mkdir_p "/tmp/bfs_test"
<       #end debug
<     #my_dir = File.join(@namespace, self.my_category)
<     #FileUtils.mkdir_p(my_dir)
< 
<     #node_data_file = my_dir + self.class.data_file_name
<     #user_data = self.to_hash
<     #raise "No data found for #{self}" unless user_data
< 
<     #desc_file = my_dir + BufsFileSystem.description_file_basename
<     #self.description = 'This description was automatically generated on #{Time.now}' unless self.description
<     #File.open(desc_file, 'w') { |f| f.write(self.description.to_s)} if self.description
<     #File.open(node_data_file, 'w') {|f| f.write(user_data.to_json)} #FIXME need to mixin model data
<     #file metadata is part of the data file itself (if it exists)
<     #self  <-- Right thing to do, but need stability beofre changing (for testing)
---
>     return self
433,434c333,334
<   def inject_node_metadata
<     inject_metadata(@user_data)
---
>   def create_view(param)
>     BufsInfoDocEnvMethods.set_view(self.class.db, self.class.design_doc, param)
437,439c337,340
<   def inject_metadata(node_data)
<     node_data.merge(@model_metadata)
<   end
---
>   #TODO: This is not being tested and currently it doesn't do anything
>   #def destroy
>   #  puts "Destroy Method Size: #{BufsInfoDoc.all.size}"
>   #end
441,444c342,346
<   def update_self(rev_data)
<     self.model_metadata.merge!(rev_data)
<     version_key = DataStoreModels::FileStore::VersionKey
<     @saved_to_model = rev_data[version_key]
---
>   #Adds parent categories, it can accept a single category or an array of categories
>   #aliased for backwards compatibility, this method is dynamically defined and generated
>   def add_parent_categories(new_cats)
>     puts "Warning:: add_parent_categories is being deprecated, use <param_name>_add instead ex: parent_categories_add(cats_to_add) "
>     parent_categories_add(new_cats)
447,455c349,360
<   def  self.create_from_doc_node(node_obj)
<     init_params = {}
<     init_params['my_category'] = node_obj.my_category
<     init_params['parent_categories'] = node_obj.parent_categories
<     init_params['description'] = node_obj.description if node_obj.description
<     new_bfs = self.new(init_params)
<     new_bfs.save
<     if node_obj.get_attachment_names.nil? || node_obj.get_attachment_names.empty?
<       #do nothing, easier to read like this
---
>   #Can accept a single category or an array of categories
>   #aliased for backwards compatiblity the method is dynamically defined and generated
>   def remove_parent_categories(cats_to_remove)
>     puts "Warning:: remove_parent_categories is being deprecated, use <param_name>_subtract instead ex: parent_categories_subtract(cats_to_remove)"
>     parent_categories_subtract(cats_to_remove)
>   end  
> 
>   #Returns the attachment id associated with this document.  Note that this does not depend upon there being an attachment.
>   #TODO: 
>   def my_attachment_doc_id
>     if self.model_metadata[:_id]
>       return self.model_metadata[:_id] + self.class.attachment_base_id
457,464c362
<       node_obj.get_attachment_names.each do |att_name|
<         raw_data = node_obj.attachment_data(att_name)
<         #att_file_name = self.namespace + '/' + new_bfs.my_category + '/' 
<         puts "Adding Raw Data For: #{node_obj.inspect}"
<         file_modified_at = node_obj.get_attachment_metadata['md_attachments'][::BufsEscape.escape(att_name)]['file_modified']
<         new_bfs.add_raw_data(att_name, new_bfs.my_category, raw_data,
<                    file_modified_at) 
<       end
---
>       raise "Can't attach to a document that has not first been saved to the db"
466,473d363
<     if node_obj.respond_to?(:list_links) && (node_obj.list_links.nil? || node_obj.list_links.empty?)
<       #do nothing, no link data
<     elsif node_obj.respond_to?(:list_links)
<       new_bfs.add_links(node_obj.list_links) 
<     else
<       #do nothing, no link method
<     end 
<     return new_bfs.class.by_my_category(new_bfs.my_category).first
476,479c366,367
<   #TODO: replace hard coded methods based on data names with dynamically generated ones
<   def add_parent_categories(new_cats)
<     puts "Warning:: add_parent_categories is being deprecated, use <param_name>_add instead ex: parent_categories_add(cats_to_add) "
<     parent_categories_add(new_cats)
---
>   def get_attachment_names
>     self.class.class_env.files_mgr.list_file_keys(self)
481,495d368
< =begin
<     current_cats = orig_cats = self.parent_categories||[]
<     #current_cats = orig_cats = self.parent_categories||[]
<     #TODO: should update node_data_hash
<     new_cats = [new_cats].flatten
<     current_cats += new_cats
<     current_cats.uniq!
<     current_cats.compact!
<     if current_cats.size > orig_cats.size
<       self.parent_categories = current_cats
<       self.save
<     end
< =end
<   alias :add_category :add_parent_categories
<   alias :add_categories :add_parent_categories
497,502c370,378
<   def remove_parent_categories(cats_to_remove)
<     #TODO: should update node_data_hash
<     cats_to_remove = [cats_to_remove].flatten
<     cats_to_remove.each do |remove_cat|
<       self.parent_categories.delete(remove_cat)
<     end
---
>   #Get attachment content.  Note that the data is read in as a complete block, this may be something that needs optimized.
>   #TODO: add_raw_data parameters to a hash?
>   def add_raw_data(attach_name, content_type, raw_data, file_modified_at = nil)
>     self.class.class_env.files_mgr.add_raw_data(self, attach_name, content_type, raw_data, file_modified_at = nil)
>   end
> 
>   def files_add(file_data)
>     attach_id = self.class.class_env.files_mgr.add_files(self, file_data)
>     self.iv_set(:attachment_doc_id, attach_id)
504d379
<     raise "temp error due to no parent categories existing" if self.parent_categories.empty?
507,548c382,383
<   #TODO: Rationalize with BufsInfoDoc
<   #FIXME: my_cat not needed?
<   def add_raw_data(file_name, my_cat, raw_data, file_modified_at = nil)
<     #file_name = unescape(file_name)  #Hack to avoid escaping twice (and changing the name in the process)
<     #content type is lost when data is saved into the file model.
<     puts "Add Raw Data --- (Unesc) File Name: #{File.basename(file_name)}"
<     esc_filename = ::BufsEscape.escape(file_name)
<     puts "Add Raw Data --- (Esc) File Name: #{File.basename(esc_filename)}"
<     raw_data_dir = #@my_dir # + my_cat
<     FileUtils.mkdir_p(raw_data_dir) unless File.exist?(raw_data_dir)
<     raw_data_filename = raw_data_dir + '/' + esc_filename
<     File.open(raw_data_filename, 'wb'){|f| f.write(raw_data)}
<     puts "Model built at: #{raw_data_filename}"
<     if file_modified_at
<       File.utime(Time.parse(file_modified_at), Time.parse(file_modified_at), raw_data_filename)
<     else
<       file_modified_at = File.mtime(raw_data_filename).to_s     
<     end
<     @file_metadata = {'file_modified' => file_modified_at}
<     @attached_files << raw_data_filename
<     @filename = esc_filename
<   end
< 
<   #TODO: Need to update spec to include multiple files 
<   def add_data_file(file_datas)
<     #TODO Use self or user_data?
<     self.class.class_env.files_mgr.add_files(self, file_datas)
<   end
< =begin
<     filenames = [filenames].flatten
<     filenames.each do |filename|
<       my_dest_basename = ::BufsEscape.escape(File.basename(filename))
<       #puts "Add Data File --- Basename (Esc) #{my_dest_basename}"
<       @filename = my_dest_basename
<       FileUtils.mkdir_p(@my_dir) unless File.exist?(@my_dir) #TODO Throw error if its a file
<       my_dest = @my_dir + '/' + @filename
<       #FIXME: obj.attached_files is broken, list_attached_files should work
<       @attached_files << my_dest
<       same_file = filename == my_dest
<       FileUtils.cp(filename, my_dest, :preserve => true, :verbose => true ) unless same_file
<       self.file_metadata = {filename => {'file_modified' => File.mtime(filename).to_s}}
<     end
---
>   def files_subtract(file_basenames)
>     self.class.class_env.files_mgr.subtract_files(self, file_basenames)
550d384
< =end
552,564c386,392
<    def attached_files?
<     #if @attached_files.size > 0
<     #  return true
<     #else
<      
<     #Its better to check the authorative model
<     if Dir.file_data_entries(path_to_node_data).size > 0
<       #raise "#{path_to_node_data.inspect}"
<       #raise "#{Dir.file_data_entries(path_to_node_data).inspect}"
<       return true
<     else
<       return false
<     end
---
> 
> #TODO: Add to spec (currently not used)  I think used by web server, need to genericize (use FilesMgr?)
>   def attachment_url(attachment_name)
>     current_node_doc = self.class.get(self['_id'])
>     att_doc_id = current_node_doc['attachment_doc_id']
>     current_node_attachment_doc = self.class.user_attachClass.get(att_doc_id)
>     current_node_attachment_doc.attachment_url(attachment_name)
566,569c394,399
<   
<   def list_attached_files
<     #FIXME: Fix @attached_files to work or get rid of it and replace with this method
<     Dir.file_data_entries(path_to_node_data)
---
> 
>   def attachment_data(attachment_name)
>     current_node_doc = self.class.get(self['_id'])
>     att_doc_id = current_node_doc['attachment_doc_id']
>     current_node_attachment_doc = self.class.user_attachClass.get(att_doc_id)
>     current_node_attachment_doc.read_attachment(attachment_name)
572,573c402,405
<   def get_attachment_names
<     list_attached_files.map {|fn| File.basename(fn)}
---
>   def get_attachment_metadata
>     current_node_doc = self.class.get(self['_id'])
>     att_doc_id = current_node_doc['attachment_doc_id']
>     current_node_attachment_doc = self.class.user_attachClass.get(att_doc_id)
576,580c408,412
<   def remove_attached_files(att_basenames)
<     att_basenames = [att_basenames].flatten
<     att_esc_bn = att_basenames.collect {|bn| BufsEscape.escape(bn)}
<     att_filenames = att_esc_bn.collect {|bn| path_to_node_data + '/' + bn}
<     FileUtils.rm_f(att_filenames)
---
>   #TODO: Genericize for all models
>   def self.db_id(node_id)
>     puts "Warning:: method db_id has been deprecated use DataStoreModels::<data store model>.generate_model_key(coll_ns, node_id) instead"
>     #@collection_namespace + '::' + node_id
>     DataStoreModels::CouchRest.generate_model_key(@class_env.collection_namespace, node_id)
583,585c415,417
<   def get_file_data
<     my_dest = @my_dir + '/' + @filename
<     return  File.open(my_dest, 'rb'){|f| f.read}
---
>   def db_id
>     puts "Warning:: instance method db_id has been deprecated use instance method model_key instead"
>     self.class.db_id(self.my_category)
588,589c420,424
<   #TODO: Which architecture for links? FileNode or InfoDoc/
<   #TODO: Move links' methods to be part of data hash?
---
>   def model_key
>     node_key = DataStructureModels::Bufs::NodeKey 
>     node_id = self.user_data[node_key]
>     DataStoreModels::CouchRest.generate_model_key(@clas_env.collection_namespace, node_id)
>   end
590a426,437
>   #meta_data should not be in node data so this shouldn't be necessary
>   #def remove_node_db_metadata
>   #  remove_node_db_metadata(@node_data_hash)
>   #end
>   
>   #this won't work as an instance method because the data needs to be
>   #purged before creating the instance
>   #def remove_db_metadata(raw_data)
>   #  db_metadata_keys = @db_metadata
>   #  db_metadata_keys.each {|k| raw_data.delete(k)}
>   #  raw_data #now with metadata removed
>   #end
592,599c439,440
<   def list_links
<     node_link_file_name = path_to_node_data + '/' + self.class.link_file_name
<     if File.exists?(node_link_file_name)
<       links =  JSON.parse(File.open(node_link_file_name) {|f| f.read})
<       return links
<     else
<       return nil
<     end
---
>   def inject_node_metadata
>     inject_metadata(@user_data)
602,620c443,444
<   def add_links(links_to_add)
<     #links_to_add = [links_to_add].flatten
<     existing_links = list_links||{}
<     updated_links = existing_links.merge(links_to_add)
<     #updated_links = list_links||[] + links_to_add
<     node_link_file_name = path_to_node_data + '/' + self.class.link_file_name
<     File.open(node_link_file_name, 'w') {|f| f.write(updated_links.to_json)}
<   end
< 
<   def remove_links(links_to_remove)
<     links_to_remove = [links_to_remove].flatten
<     if list_links
<       updated_links = list_links - links_to_remove
<       node_link_file_name = path_to_node_data + '/' + self.class.link_file_name
<       File.open(node_link_file_name, 'w') {|f| f.write(updated_links.to_json)}
<       return updated_links
<     else
<       return []
<     end
---
>   def inject_metadata(node_data)
>     node_data.merge(@model_metadata)
623,634c447,450
<   def destroy_node
<     if self.my_category
<       #TODO: my_dir should be from path_to_node_data?
<       my_dir = self.class.namespace + '/' + self.my_category + '/'
<       p "Destroying: #{my_dir}"
<       #rm_f(Dir.glob(my_dir + '*'))
<       FileUtils.remove_dir(my_dir, :force => true)
<       #how to set self to nil?
<     else
<       raise "Cannot destroy node, cannot determine its category, has it been saved?"
<     end
<     raise "Error, unable to delete file data: #{my_dir}" if File.exists?(my_dir)
---
>   def update_self(rev_data)
>     self.model_metadata.merge!(rev_data)
>     version_key = DataStoreModels::CouchRest::VersionKey
>     @saved_to_model = rev_data[version_key]
636d451
<   alias destroy :destroy_node
637a453,456
>   #Deletes the object and its CouchDB entry
>   def destroy_node
>     DataStoreModels::CouchRest::destroy_node(self)
>   end
